{
  "arrays": "# Arrays\n\nThere are a number of functions designed to make working with arrays easier. They largely mimic similar functions found in core Python or the `numpy` library.\n\n## Functions\n\n- `zip(...arrs)` — combine arrays `arrs` element-wise\n- `min(...arrs)` — the minimum of arrays `arrs`\n- `max(...arrs)` — the maximum of arrays `arrs`\n- `reshape(arr, shape)` — reshape array `arr` to given dimensions `shape`\n- `split(arr, len)` — split array `arr` into subarrays of length `len`\n- `sum(arr)` — sum the elements of array `arr`\n- `all(arr)` — check if all elements of array `arr` are true\n- `any(arr)` — check if any element of array `arr` is true\n- `add(arr1, arr2)` — add arrays `arr1` and `arr2` element-wise\n- `mul(arr1, arr2)` — multiply arrays `arr1` and `arr2` element-wise\n- `cumsum(arr, first=true)` — compute the cumulative sum of array `arr` with the option to start at zero\n- `norm(arr, degree=1)` — compute the `degree`-norm of array `arr`\n- `normalize(arr, degree=1)` — normalize array `arr` to have `degree`-norm one\n- `range(i0, i1, step=1)` — generate an array of evenly spaced values from `i0` to `i1` with spacing `step`\n- `linspace(x0, x1, n=50)` — generate an array of `n` evenly spaced values between `x0` and `x1`\n- `enumerate(arr)` — pair each element of array `arr` with its index\n- `repeat(x, n)` — repeat array `x` a total of `n` times\n- `meshgrid(x, y)` — create a mesh grid from arrays `x` and `y`\n- `lingrid(xlim, ylim, N)` — create a 2D grid of `N = [Nx, Ny]` points over the ranges `xlim` and `ylim`\n",
  "axis": "# Axis\n\n*Inherits*: [Group](/docs/group) > [Element](/docs/element)\n\nA single vertical or horizontal axis for plotting. This includes the central line, the perpendicual ticks, and their associated tick labels. Note that the proper bounds encompass only the central line and ticks, while the tick labels may fall well outside of them. Use **HAxis** and **VAxis** for specific directions.\n\nParameters:\n- `direc` — the orientation of the axis, either `v` (vertical) or `h` (horizontal)\n- `ticks` — a list of tick `[location, label]` pairs. The label can either be an `Element` or a string\n- `lim` = `[0, 1]` — the extent of the element along the main axis\n- `tick_pos` = `'both'` — one of `'inner'` / `'outer'` / `'both'` / `'none'` , or a pair representing a numerical range in `[0, 1]`, where zero is oriented in the inner direction\n\nSubunits:\n- `line`: the central line along the main axis\n- `tick`: the perpendicular tick marks (collectively)\n- `label`: the labels annotating the tick marks (collectively)\n",
  "barplot": "# BarPlot\n\n*Inherits*: [Plot](/docs/plot) > [Container](/docs/container) > [Element](/docs/element)\n\nMakes a plot featuring a bar graph. This largely wraps the functionality of [Plot](/docs/plot) but takes care of labelling and arranging the `xaxis` information. You can provide `label` and `size` attributes to the child elements. The **Bar**/**VBar**/**HBar** elements are just very thin wrappers around **Rect** elements, and you can use other elements in their place if you wish.\n\nChild parameters:\n- `label` — the label for the bar\n- `size` — the height of the bar\n\nParameters:\n- `direc` = `v` — the orientation of the bars in the plot\n\nSubunit names:\n- `bar` — keywords to pass to the underlying **Bars** element\n",
  "box": "# Box\n\n*Inherits*: [Group](/docs/group) > [Element](/docs/element)\n\nThis is a simple container class allowing you to add padding, margins, and a border to a single **Element**. It's pretty versatile and is often used to set up the outermost positioning of a figure. Mirroring the standard CSS definitions, padding is space inside the border and margin is space outside the border. There is a specialized subclass of this called **Frame** that defaults to `border = 1`.\n\nThere are multiple ways to specify padding and margins. If given as a scalar, it is constant across all sides. If two values are given, they correspond to the horizontal and vertical sides. If four values are given, they correspond to `[left, top, right, bottom]`.\n\nThe `adjust` flag controls whether padding/margins are adjusted for the aspect ratio. If `true`, horizontal and vertical components are scaled so that their ratio is equal to the `child` element's aspect ratio. This yields padding/margins of constant apparent size regardless of aspect ratio. If `false`, the inputs are used as-is.\n\nParameters:\n- `padding` = `0` / `0.1` — the padding to be added (inside border)\n- `margin` = `0` / `0.1` — the margin to be added (outside border)\n- `border` = `0` / `1` — the border width to use\n- `rounded` = `0` / `0.1` — the border rounding to use\n- `adjust` = `true` — whether to adjust values for aspect ratio\n- `shape` = `Rect` — the shape class to use for the border\n\nSubunit names:\n- `border` — keywords to pass to border, such as `stroke` or `stroke-dasharray`\n",
  "colors": "# Colors\n\nThere are a few functions designed to manipulate colors in HEX, RGB, and HSL formats.\n\n## Constants\n\n- `none` = `'none'` — a transparent color\n- `white` = `'#ffffff'` — a white color\n- `black` = `'#000000'` — a black color\n- `blue`= `'#1e88e5'` — a neon blue color\n- `red`= `'#ff0d57'` — a neon red color\n- `green`= `'#4caf50'` — a neon green color\n- `yellow`= `'#ffb300'` — a neon yellow color\n- `purple`= `'#9c27b0'` — a neon purple color\n- `gray`= `'#f0f0f0'` — a light gray color\n\n## Functions\n\n- `hex2rgb(hex)` — convert a HEX color string to an RGB array\n- `rgb2hex(rgb)` — convert an RGB array to a HEX color string\n- `rgb2hsl(rgb)` — convert an RGB array to an HSL array\n- `palette(beg, end)` — create a palette function that interpolates between two colors\n",
  "context": "# Context\n\nThis is the class the handles the flow of information down the [Element](/docs/element) chain as rendering happens. Essentially, it contains information about the absolute location (in pixels) of the current Element and provides methods for mapping from coordinate positions within that Element (such as `[0.3, 0.6]`) to pixel positions (such as `[100, 250]`).\n\nThe most commonly used would be `mapPoint` for positions, `mapRect` for areas, and `mapSize` for sizes. These are used as the core logic in most custom Element classes. See [Element](/docs/element) for more information on their proper usage in that setting.\n\nThe `map` function is used generate a subcontext for child elements. The input `rect` specifies where to place the child in the coordinate system of the parent, while the `coord` argument specifies a new coordinate system for the child to use. The canonical usage of the `coord` argument is in [Graph](/docs/graph), where we want to place the graph in a particular spot but specify child positions in an arbitrary coordinate system.\n\nFor children with `null` aspects, this is the end of the story. However, when the child aspect is specified, we may not be able to fit it into `rect` snugly. In this case we either shrink it down so that if fits both vertically or horizontally (`expand = false`) or blow it up until it (weakly) exceeds its bounds in both directions (`expand = true`). Related complications are introduced when `rotate` is non-null. See [Group](/docs/group) for a list of inputs to `map`.\n\nMethods:\n- `constructor({ prect, coord })`: create a new `Context`\n- `mapPoint(point)`: map a coordinate position to a pixel position\n- `mapRect(rect)`: map a coordinate rectangle to a pixel rectangle\n- `mapSize(size)`: map a coordinate size to a pixel size\n- `mapRange(direc, limit)`: map a coordinate range to a pixel range\n- `map({ rect, aspect, expand, align, rotate, invar })`: return a sub-`Context` for a given coordinate rectangle\n",
  "datafill": "# DataFill\n\n*Inherits*: [Polygon](/docs/polygon) > [Element](/docs/element)\n\nFlexible interface to generate filled in paths symbolically or in combination with fixed inputs. This generates a polygon by running through the points generated by `fx1`/`fy1` and then backwards through the points generated by `fx2`/`fy2`. To generate a simple filled curve, pass your function to `fy1` and let `fy2` be `0`.\n\nParameters:\n- `fx1`/`fy1` — a function generating one of the bounds for the fill (or a constant)\n- `fx2`/`fy2` — a function generating the other bound for the fill (or a constant)\n- `xlim`/`ylim`/`tlim` — a pair of numbers specifying variable limits\n- `xvals`/`yvals`/`tvals` — a list of x-values, y-values, or t-values to use\n- `N` — number of data points to generate when using limits\n",
  "datapath": "# DataPath\n\n*Inherits*: [Polyline](/docs/polyline) > [Pointstring](/docs/pointstring) > [Element](/docs/element)\n\nFlexible interface to generate two-dimensional paths symbolically or in combination with fixed inputs. There are variety of acceptable input combinations, but the most common usage is to specify the range to use for x-values with `xlim` and a function to plot with `fy`.\n\nAlternatively, you can specify the transpose with `ylim`/`fx`, or even do a fully parametric path using `tlim`/`fx`/`fy`. In any of these cases, one can either specify limits with `xlim`/`ylim`/`tlim` or specific values with `xvals`/`yvals`/`tvals`.\n\nYou'll often want to use [Plot](/docs/plot) to display these curves, as they might otherwise come out looking upside down relative to what you expect (as higher y-values mean \"down\" in raw SVG).\n\nParameters:\n- `fx`/`fy` — a function mapping from x-values, y-values, or t-values\n- `xlim`/`ylim`/`tlim` — a pair of numbers specifying variable limits\n- `xvals`/`yvals`/`tvals` — a list of x-values, y-values, or t-values to use\n- `N` — number of data points to generate when using limits\n",
  "datapoints": "# DataPoints\n\n*Inherits*: [Group](/docs/group) > [Element](/docs/element)\n\nFlexible interface to generate sets of points symbolically or in combination with fixed inputs. The most common usage is to specify the range for x-values with `xlim` and a function to plot with `fy`. But you can specify the transpose with `ylim`/`fx`, or do a fully parametric path using `tlim`/`fx`/`fy`.\n\nYou can also specify the radius of the points functionally with `size` and the shape with `children`. Both of these functions take `(x, y, t, i)` values as inputs and return the desired value for each point.\n\nParameters:\n- `children` = `Dot` — a shape or function mapping from `(x, y, t, i)` values to a shape\n- `fx`/`fy` — a function mapping from x-values, y-values, or t-values\n- `size` = `0.025` — a size or a function mapping from `(x, y, t, i)` values to a size\n- `xlim`/`ylim`/`tlim` — a pair of numbers specifying variable limits\n- `xvals`/`yvals`/`tvals` — a list of x-values, y-values, or t-values to use\n- `N` — number of data points to generate when using limits\n",
  "datapoly": "# SymPoly\n\n*Inherits*: [Polygon](/docs/polygon) > [Element](/docs/element)\n\nFlexible interface to generate polygons symbolically or in combination with fixed inputs. Operates similarly to [SymPoints](/docs/sympoints), but generates a polygon from the points generated by `fx`/`fy`.\n\nParameters:\n- `fx`/`fy` — a function mapping from x-values, y-values, or t-values\n- `xlim`/`ylim`/`tlim` — a pair of numbers specifying variable limits\n- `xvals`/`yvals`/`tvals` — a list of x-values, y-values, or t-values to use\n- `N` — number of data points to generate when using limits\n",
  "edge": "# Edge\n\n*Inherits*: [Group](/docs/group) > [Element](/docs/element)\n\nThis creates a cubic spline path from one point to another with optional arrowheads at either or both ends. It is named **Edge** because of its usage in network diagrams with [Network](/docs/network). The emanation directions are automatically inferred from the relative point positions but can be overriden as well.\n\nParameters:\n- `node1`/`node2` — the beginning and ending [Node](/docs/node) for the path and where the optional arrowheads are placed, or a `[node, direc]` pair where `direc` specifies the emanation direction\n- `dir1`/`dir2` — the emanation directions of the arrowheads, either `'n'`/`'s'`/`'e'`/`'w'` or a `[dx, dy]` pair\n- `arrow`/`arrow_beg`/`arrow_end` — toggles whether the respective arrowheads are included. Defaults to `true` for `arrow_end` and `false` for `arrow_beg`, meaning a directed graph edge\n- `arrow_size` = `0.03` — the arrowhead size to use for both arrows\n- `arrow_base` — toggles whether the arrowhead base is included\n\nSubunits:\n- `arrow`/`arrow_beg`/`arrow_end` — the respective arrowheads, with `arrow` being applied to both\n- `path` — the connecting line element\n",
  "element": "# Element\n\nThe base class for all `gum.js` objects. You will usually not be working with this object directly unless you are implementing your own custom elements. An **Element** has a few methods that can be overriden, each of which takes a [Context](/docs/context) object as an argument. The vast majority of implementations will override only `props` and `inner` (for non-unary elements).\n\nParameters:\n- `tag` = `g` — the SVG tag associated with this element\n- `unary` = `false` — whether there is inner text for this element\n- `aspect` = `null` — the width to height ratio for this element\n- `pos` — the desired position of the center of the child's rectangle\n- `rad` ­— the desired radius of the child's rectangle (can be single number or pair)\n- `rect` — a fully specified rectangle to place the child in (this will override `pos`/`rad`)\n- `aspect` — the aspect ratio of the child's rectangle\n- `expand` — when `true`, instead of embedding the child within `rect`, it will make the child just large enough to fully contain `rect`\n- `align` — how to align the child when it doesn't fit exactly within `rect`, options are `left`, `right`, `center`, or a fractional position (can set vertical and horizontal separately with a pair)\n- `rotate` — how much to rotate the child by (degrees counterclockwise)\n- `spin` — like rotate but will maintain the same size\n- `vflip/hflip` — flip the child horizontally or vertically\n- `flex` ­— override to set `aspect = null`\n- `...` = `{}` — additional attributes that are included in `props`\n\nMethods:\n- `props(ctx)` — returns a dictionary of attributes for the SVG element. The default implementation returns the non-null `attr` passed to the constructor\n- `inner(ctx)` — returns the inner text of the SVG element (for non-unary). Defaults to returing empty string\n- `svg(ctx)` — returns the rendered SVG of the element as a `String`. Default implementation constructs SVG from `tag`, `unary`, `props`, and `inner`\n",
  "ellipse": "# Ellipse\n\n*Inherits*: [Element](/docs/element)\n\nThis makes an ellipse. Without any arguments it will inscribe its allocated space. Use **Circle** for a circle with a unit aspect.\n",
  "emoji": "# Emoji\n\n*Inherits*: [Element](/docs/element)\n\nCreates a new `Emoji` element from a Github emoji name (like \"smile\" = \"🙂\"). Note that you do not need to include the \":\" characters around the name.\n\nYou can find a list of the Github emoji names [here](https://github.com/ikatyang/emoji-cheat-sheet). If the emoji is not found, it will display the name in red. Note that you can also simply use the **Text** element to display an emoji by passing the emoji character itself as the text, rather than the name.\n\nParameters:\n- `name` — the name of the emoji\n",
  "graph": "# Graph\n\n*Inherits*: [Group](/docs/group) > [Element](/docs/element)\n\nThis is the core graphing functionality used in [Plot](/docs/plot) without the axes and labels. The default coordinate system is the unit square, `[0, 0, 1, 1]`. This can be overridden with custom `xlim`/`ylim` specifications. The Elements that are passed to **Graph** can express their position and size information in this new coordinate system.\n\nParameters:\n- `xlim`/`ylim` = `[0, 1]` — the range over which to graph\n- `padding` = `0` — limit padding to add when auto-detected from `elems`\n- `coord` — the coordinate system to use for the graph (overrides `xlim`/`ylim`)\n",
  "grid": "# Grid\n\n*Inherits*: [Group](/docs/group) > [Element](/docs/element)\n\nThis element creates a container that arranges its children in a grid. The grid is specified by the number of rows and columns, and the gap between the cells. In the case where `widths` and `heights` are not specified, a reasonable effort is made to best accomodate the grid elements based on their aspects (if specified).\n\nParameters:\n- `rows` = `N` — the number of rows in the grid (autodetected)\n- `cols` = `M` — the number of columns in the grid (autodetected)\n- `widths` = `[1/N,...]` — an array of widths for each column\n- `heights` = `[1/M,...]` — an array of heights for each row\n- `spacing` = `0` — the gap between the cells in the grid\n",
  "group": "# Group\n\n*Inherits*: [Element](/docs/element)\n\nThis is the main container class that all compound elements are derived from. It accepts a list of child elements and attempts to place them according to their declared properties.\n\nPlacement positions are specified in the group's internal coordinate space, which defaults to the unit square. The child's `aspect` is an important determinant of its placement. When it has a `null` aspect, it will fit exactly in the given `rect`. However, when it does have an aspect, it needs to be adjusted in the case that the given `rect` does not have the same aspect. The `expand` and `align` specification arguments govern how this adjustment is made.\n\nParameters:\n- `children` = `[]` — a list of child elements\n- `aspect` = `null` — the aspect ratio of the group's rectangle (can pass `'auto'` to infer from the children)\n- `coord` = `[0, 0, 1, 1]` — the internal coordinate space to use for child elements (can pass `'auto'` to contain children's rects)\n",
  "gum": "# gum.js\n\nWelcome to the gum.js docs! Click on an item in the list on the left to get more info about a particular class (usually an [Element](#Element), function, or constant).\n\nEach entry has a description of the operation and arguments of the item and an associated example code snippet. You can edit the code snippet, but note that these will get clobbered if you navigate to another entry! Go to the [main editor](/) for non-ephemeral work.\n\nThe syntax is an XML component style one familiar to React developers. The output is pure SVG. You can nest objects in interesting ways and specify their parameters. Positions and sizes are specified proportionally (i.e. between `0` and `1`), but some quantities like `border` or `stroke-width` are specified in absolute units.\n\n## Common Patterns\n\n*Parameter specification*: You can specify boolean parameters like `border` just by writing their name. Some parameters, such as `padding` default to `0` when not specified but have a default true value as well (in that case `0.1`). You can also pass SVG properties such as `stroke-width` directly.\n\n*Subunit arguments*: for compound elements that inherit [Container](#Container), some keyword arguments are passed down to the constituent parts. For instance, in [Plot](#Plot), one can specify arguments intended for the `XAxis` unit by prefixing them with `xaxis-`. For example, setting the `stroke-width` for this subunit can be achieved with `xaxis-stroke-width`.\n",
  "latex": "# Math\n\n*Inherits*: [Text](/docs/text) > [Element](/docs/element)\n\nCreates a new `Math` math element from LaTeX source. Uses `MathJax` when available to render in SVG and calculate aspect ratio. This is also implicitly accessible through [TextFrame](/docs/textframe) when passing the `latex` flag. As seen in the example, you will probably need to wrap the LaTeX in `{\"...\"}` to prevent syntax errors.\n\nParameters:\n- `offset` — the position of the center of the element\n- `scale` — the proportional size of the element\n",
  "line": "# Line\n\n*Inherits*: [Element](/docs/element)\n\nThe `Line` element is a basic geometric element that draws a line between two points. There are specialized variants for vertical and horizontal lines called **VLine** and **HLine**, which allow you to specify the position of the line (`loc`) and the range of the line (`lim`). See [UnitLine](/docs/unitline) for more details.\n\nParameters:\n- `pos1` — the coordinate of the first point\n- `pos2` — the coordinate of the second point\n",
  "math": "# Math\n\nHere we collect a variety of global mathematical functions and constants. You can still use the core JavaScript `Math` library as well.\n\n## Constants\n\n- `e` — the base of the natural logarithm (e)\n- `pi` — the geometric constant (π)\n- `phi` — the golden ratio (φ)\n- `r2d` — the conversion factor between radians and degrees (180/π)\n- `d2r` — the conversion factor between degrees and radians (π/180)\n\n## Functions\n\n- `exp(x)` — the exponential function\n- `log(x)` — the natural logarithm\n- `sin(x)` — the sine function\n- `cos(x)` — the cosine function\n- `tan(x)` — the tangent function\n- `abs(x)` — the absolute value\n- `pow(x, y)` — the power function\n- `sqrt(x)` — the square root function\n- `sign(x)` — the sign function\n- `floor(x)` — the floor function\n- `ceil(x)` — the ceiling function\n- `round(x)` — the rounding function\n- `clamp(x, lim)` — clamp `x` to the range `lim`\n- `rescale(x, lim)` — linearly rescale `x` to the range `lim`\n",
  "network": "# Network\n\n*Inherits*: [Group](/docs/group) > [Element](/docs/element)\n\nNetwork diagrams can be created using the [Node](/docs/node) and [Edge](/docs/edge) classes. This automatically processes Node and Edge children to create a network diagram. It will also display non-network elements as they would be displayed in a [Graph](/docs/graph).\n\nYou can specify the internal coordinate system using the `coord` argument, which is a 4-element array specifying the position of the bottom left corner and the width and height of the coordinate system. For example, `coord: [0, 0, 1, 1]` specifies the unit square. When using `Graph`, one can also pass in `xlim`/`ylim` arguments to specify the extent of the graph.\n\nParameters:\n- `coord` — the internal coordinate system to use, a 4-element array specifying the position of the bottom left corner and the width and height of the coordinate system\n\nSubunits:\n- `node`/`edge` — the nodes and edges, respectively (TODO)\n",
  "node": "# Node\n\n*Inherits*: [Frame](/docs/frame) > [Element](/docs/element)\n\nThis is a container class that encloses text in a **Frame** at a particular position. Passing a string or list of strings to `text` will automatically create a **MultiText** node. One can also simply pass a generic **Element**. The primary usage of this is in the creation of networks using the [Network](/docs/network) container. You must provide a `label` argument to reference this in an [Edge](/docs/edge) element.\n\nParameters:\n- `label` — a string or **Element** to be used as the label\n- `rad` = `0.1` — the radius of the node box (will adjust to aspect)\n- `padding` = `0.1` — the padding of the node box\n- `border` = `1` — the border width of the node box\n- `rounded` = `0.05` — the radius of the corners of the node box\n\nMethods:\n- `get_anchor(direc)` — returns the anchor point of the node in the specified direction (`n`, `s`, `e`, `w`)\n",
  "plot": "# Plot\n\n*Inherits*: [Group](/docs/group) > [Element](/docs/element)\n\nThis will graph one or more elements over the desired limits and frame them with axes. If not specified by `xlim` and `ylim`, the limits of the plot will be computed from the bounding box of the constituent elements. By default, the `aspect` will be the ratio of the range of the `xlim` and `ylim`.\n\nParameters:\n- `xlim`/`ylim` = `[0, 1]` — the range over which to graph\n- `xanchor`/`yanchor` — the value at which to place the respective axis. Note that the `xanchor` is a y-value and vice versa. Defaults to `xmin`/`ymin`\n- `xticks`/`yticks` = `5` — either an integer for evenly spaced ticks, a list of tick locations, or list of tick `[location, label]` pairs (see [Axis](/docs/axis) for more details)\n- `xgrid`/`ygrid` = `false` — whether to show a grid in the background. If `true`, the grid lines match the specified ticks. Alternatively, you can pass a list of positions to override this\n- `xlabel`/`ylabel` — a string or **Element** to use as the respective label\n- `title` — a string or **Element** to use as the title\n\nSubunits:\n- `xaxis`/`yaxis`/`axis` — the axes, including lines, ticks, and tick labels\n- `xgrid`/`ygrid`/`grid` — the grid lines arrayed under the graph\n- `xlabel`/`ylabel`/`label` — the axis label elements\n- `title` — the title element\n",
  "points": "# Points\n\n*Inherits*: [Group](/docs/group) > [Element](/docs/element)\n\nPlace copies of a common shape at various points. The radius can be specified by the `size` keyword and overridden for particular children. The default shape is a black dot.\n\nKeyword arguments:\n- `children` — a list of points, where each point is either an `[x,y]` pair\n- `size` = `0.025` — the default radius to use for children\n- `shape` = `Dot` — the default shape to use for children\n- `...` = `{}` — additional attributes are passed to the default shape (like `stroke` or `fill`)\n",
  "polyline": "# Polyline\n\n*Inherits*: [Pointstring](/docs/pointstring) > [Element](/docs/element)\n\nThis will draw a multi-segment line. The **Polygon** element has the same syntax but will connect the first and last point.\n\nParameters:\n- `children` — list of point coordinates (length two or more)\n",
  "rect": "# Rect\n\n*Inherits*: [Element](/docs/element)\n\nThis makes a rectangle. Without any arguments it will fill its entire allocated space. Unless otherwise specified, it has a `null` aspect. Use **Square** for a square with a unit aspect.\n\nSpecifying a `rounded` argument will round the borders by the same amount for each corner. This can be either a scalar or a pair of scalars corresponding to the x and y radii of the corners. To specify different roundings for each corner, use the **RoundedRect** element.\n\nParameters:\n- `rounded` = `null` — proportional border rounding, accepts either scalar or pair of scalars\n",
  "stack": "# Stack\n\n*Inherits*: [Group](/docs/group) > [Element](/docs/element)\n\nStack one or more **Element** either vertically or horizontally. There are specialized components **VStack** and **HStack** that don't take the `direc` argument. Expects a `stack-size` parameter for each child.\n\nChildren with `null` size will be given remaining space. This behavior depends on the `expand` flag. If `expand` is `false`, the remaining space is split evenly. If `expand` is `true`, then space is distributed in inverse proportion to the child's aspect ratio, so that all elements will reach full width (in the **VStack** case) or full height (in the **HStack** case).\n\nChild parameters:\n- `stack-size` = `null` — the size of the child element\n- `stack-expand` = `true` — whether to expand the child to fill the remaining space\n\nParameters:\n- `direc` — the direction of stacking: `v` or `h`\n- `spacing` = `0` — total amount of space to add between child elements\n",
  "text": "# Text\n\n*Inherits*: [VStack](/docs/vstack) > [Element](/docs/element)\n\nDisplays text. Uses built-in browser facilities when available to calculate font size and aspect ratio. Note that you will typically not set the font size of the text here, as this will fill the entire space with the provided text.\n\nIf `wrap` is specified, the text will be wrapped to the specified width. In either case, newlines will be respected, though other whitespace will be compressed. There are a number of related elements that can handle different types of text:\n\n- [TextBox](/docs/textbox) can handle text with a border and background\n- [TextFlex](/docs/textflex) can handle text with a border and background\n- [TextStack](/docs/textstack) can handle multiple lines of text that are passed in as an array\n\nParameters:\n- `children` — the text to display\n- `wrap` = `null` — the width (in ems) to wrap the text at (if `null`, the text will not be wrapped)\n- `spacing` = `0.2` — the spacing between lines of text\n- `justify` = `'left'` — the horizontal justification of the text\n- `color` = `black` — sets the text color using both stroke and fill (this is the usual way)\n- `font_family` = `'IBMPlexSans'` — the font family (for display and size calculations)\n- `font_weight` = `100` — the font weight (for display and size calculations)\n",
  "textbox": "# TextBox\n\n*Inherits*: [Box](/docs/box) > [Group](/docs/group) > [Element](/docs/element)\n\nThis is a specialized relative of [Text](/docs/text) that wraps the text in a [Box](/docs/box). Note that the default padding is non-zero. There is a specialized class called **TextFrame** that defaults to `border = 1`.\n\nParameters:\n- `padding` = `0.1` — the padding\n",
  "titleframe": "# TitleFrame\n\n*Inherits*: [Frame](/docs/frame) > [Element](/docs/element)\n\nA special type of [Frame](/docs/frame) that places a title element in a box centered on the line at the top of the frame. The title element can be either a proper Element or a string, in which case it will be wrapped in a [Text](/docs/text) element.\n\nParameters:\n- `title` — the text or element to use as the title\n- `title_size` = `0.05` — the size of the title element\n- `adjust` = `true` — whether to adjust the padding and margin to account for the title element\n- `border` = `1` — the outer frame border width to use\n\nSubunits:\n- `title` — the title element\n",
  "triangle": "# Triangle\n\n*Inherits*: [Polygon](/docs/polygon) > [Pointstring](/docs/pointstring) > [Element](/docs/element)\n\nThis makes a triangle in the desired position and size. The top of the triangle is in the middle of the top edge and the bottom runs along the bottom edge.\n",
  "unitline": "# UnitLine\n\n*Inherits*: [Line](/docs/line)\n\nDraw a horizontal or vertical line at a particular position over a particular range. The position will be `0.5` and the range will be `[0, 1]`. There are also specialized variants for vertical and horizontal lines called **VLine** and **HLine**.\n\nParameters:\n- `direc` — the direction of the line (`'v'` or `'h'`)\n- `loc` = `0.5` — the position of the line\n- `lim` = `[0, 1]` — the range of the line\n"
}